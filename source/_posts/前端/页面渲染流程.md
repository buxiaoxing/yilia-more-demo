---
title: 页面渲染流程
date: 2022-02-21 19:28:52
tags:
    - 性能
    - 前端
---
**心甘情愿，这四个字真是卑微又勇敢**
<!--more-->
1. 浏览器通过请求得到一个HTML文本
2. 渲染进程解析HTML文本，构建DOM树
3. 解析HTML的同时，如果遇到内联样式或者样式脚本，则下载并构建样式规则（stytle rules），若遇到JavaScript脚本，则会下载执行脚本。（下载样式脚本是异步的，js脚本默认不是异步的，会阻塞页面渲染）
4. DOM树和样式规则构建完成之后，渲染进程将两者合并成渲染树（render tree）
5. 渲染进程开始对渲染树进行布局，计算元素的几何信息，生成布局树（layout tree）（第一次叫布局，后面叫回流）
6. 渲染进程对布局树进行绘制，生成绘制记录（第一次叫绘制，后面就叫重绘）
7. 渲染进程的对布局树进行分层，分别栅格化每一层，并得到合成帧
8. 渲染进程将合成帧信息发送给GPU进程显示到页面中


**浏览器对回流重绘的优化**
> 由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！**当你获取布局信息的操作的时候，会强制队列刷新**，比如当你访问以下属性或者使用以下方法
>
> - offsetTop、offsetLeft、offsetWidth、offsetHeight
> - scrollTop、scrollLeft、scrollWidth、scrollHeight
> - clientTop、clientLeft、clientWidth、clientHeight
> - getComputedStyle()
>
> 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来

**最小化重绘与重排**

> 减少发生次数，合并多次对dom和样式的修改，由于浏览器对回流与重绘的优化，这个很少考虑

**避免触发同步布局事件**

> 获取布局信息的操作的信息的时候，会导致浏览器强制刷新队列，减少调用布局信息的api，将值缓存起来。

**复杂动画，脱离文档流**

> 动画会经常引起重排与重绘，让其脱离文档流，减少其他元素的重排与重绘

**css3硬件加速(GPU加速)**

> 利用GPU来代替浏览器的渲染引擎，**transform、opacity、filters** 会开启硬件加速，并不会导致回流与重绘。