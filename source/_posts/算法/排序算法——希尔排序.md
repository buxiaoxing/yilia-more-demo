---
title: 排序算法——希尔排序
date: 2021-01-06 16:01:12
tags:
    - 算法
---
**君埋泉下泥销骨，我寄人间雪满头**
<!--more-->
- 排序逻辑

  > 希尔排序是在插入排序的优化，插入排序当一个小的数在右边的时候，以为插入排序只能交换相邻的数据，则需要很多次交换操作才能将前面序列保持有序，故希尔排序加入交换步长，能够交换相隔很远的数据，先队列排至大致有序，极大的提高了插入排序的效率

  图示

  - 交换排序

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720220017895-2037494031.png)
    
  - 希尔排序

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720220029758-1529678786.png)

  - 初始队列

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720210541722-57793447.png)

  - 步长为2

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720220044052-61773198.png)

    > 如果是直接插入排序，则此处需要交换两次

  - 步长为1

    就是普通的插入排序了

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720210636862-1205988842.png)

  

- 代码示例

  ```java
  public static void shellSort(int[] arr){
      //遍历所有步长
      for(int d = arr.length/2; d>0; d/=2){
          //遍历所有元素
          for(int i=d;i<arr.length;i++){
  
              for(int j=i-d;j>=d;j-=d){
                  if(arr[j]>arr[j+d]){
                      int temp = arr[j];
                      arr[j] = arr[j+d];
                      arr[j+d] = temp;
                  }
              }
          }
      }
  }
  ```

  

- 时间复杂度

  O(nlogn)

