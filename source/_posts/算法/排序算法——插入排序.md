---
title: 排序算法——插入排序
date: 2021-01-06 15:59:01
tags:
    - 算法
---
**如果你提前知道你人生的结局，你是否还有勇气，重来一遍？**
<!--more-->
- 排序逻辑

  > 每次遍历，保证前面的队列是有序的

  - 初始队列

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720210541722-57793447.png)

  - 第一轮

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720212112894-1204380124.png)

  - 第二轮

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720212131322-742312024.png)



  - 第三轮

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720212146978-1179690681.png)

  - 第四轮

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720212200986-69558690.png)

- 代码示例

  ```java
  public static void insertSort(int[] arr){
    //从第二个数开始遍历所有的数字，每一次遍历保证前面的序列是有序的
    for(int i=1;i<arr.length;i++){
        //每次遍历保证前面的序列有序
        for(j=i-1;j>=0;j--){
            if(arr[j]>arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+d];
                arr[j+d] = temp;
            }
        }
    }
  }
  ```

  选择排序每次都需要遍历前面所有的队列，但因为前面序列本身就是有序的，所以当前数大于前面一个数时，则不需要向前遍历，故可以小小优化一下

  ```java
  public static void insertSort(int[] arr){
      //从第二个数开始遍历所有的数字，每一次遍历保证前面的序列是有序的
      for(int i=1;i<arr.length;i++){
          //如果当前数字比前一个小则遍历前面的队列，否则加上该数队列仍然是有序的
          if(arr[i]<arr[i-1]){
              //将当前值存到 temp 中
              int temp = arr[i];
              int j;
              //从前一个数字向前遍历，每一个比 temp 大的数赋给它的后一位
              for(j=i-1;j>=0&&temp<arr[j];j--){
                  //每一个比 temp 大的数，将当前数赋给后一个数
                  arr[j+1] = arr[j];
              }
              //直到不比 temp 大的数，将 temp 赋给该位
              arr[j+1] = temp;
          }
      }
  }
  ```

  

- 事件复杂度

  O(n<sup>2</sup>)
