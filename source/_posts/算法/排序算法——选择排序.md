---
title: 排序算法——选择排序
date: 2021-01-06 15:58:04
tags:
    - 算法
---
**随遇而安无不可，人间到处是花香**
<!--more-->
- 排序逻辑

  > 每一轮找出剩余队列中的最小值放在前面

  - 初始队列

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720210541722-57793447.png)



  - 第一轮

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720210603737-839275738.png)



  - 第二轮

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720210617937-173939011.png)



  - 第三轮

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720210636862-1205988842.png)



- 代码示例

  ```java
  public static void selectSort(int[] arr){
      for(int i=0; i<arr.length-1; i++){
          int min = i;
          for(int j=i+1; j<arr.length; j++){
              count ++;
              if(arr[j]<arr[min]){
                  min = j;
              }
          }
          if(min!=i){
              arr[i] = arr[i]+arr[min];
              arr[min] = arr[i] - arr[min];
              arr[i] = arr[i] - arr[min];
          }
      }
  }
  ```

- 事件复杂度

  O(n<sup>2</sup>)



#### 排序算法——希尔排序

- 排序逻辑

  > 希尔排序是在插入排序的优化，插入排序当一个小的数在右边的时候，以为插入排序只能交换相邻的数据，则需要很多次交换操作才能将前面序列保持有序，故希尔排序加入交换步长，能够交换相隔很远的数据，先队列排至大致有序，极大的提高了插入排序的效率

  图示

  - 交换排序

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720220017895-2037494031.png)
    
  - 希尔排序

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720220029758-1529678786.png)

  - 初始队列

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720210541722-57793447.png)

  - 步长为2

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720220044052-61773198.png)

    > 如果是直接插入排序，则此处需要交换两次

  - 步长为1

    就是普通的插入排序了

    ![](https://gitee.com/buxiaoxing/image-bed/raw/master/img/1747833-20200720210636862-1205988842.png)

  

- 代码示例

  ```java
  public static void shellSort(int[] arr){
      //遍历所有步长
      for(int d = arr.length/2; d>0; d/=2){
          //遍历所有元素
          for(int i=d;i<arr.length;i++){
  
              for(int j=i-d;j>=d;j-=d){
                  if(arr[j]>arr[j+d]){
                      int temp = arr[j];
                      arr[j] = arr[j+d];
                      arr[j+d] = temp;
                  }
              }
          }
      }
  }
  ```

  

- 时间复杂度

  O(nlogn)


